<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Genetic Algorithm | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="&amp;emsp;&amp;emsp;遗传算法是借鉴生物界的进化规律(适者生存,优胜劣汰)的遗传机制，演化而来的随机全局搜索和优化算法。它是由美国教授于1975年首先提出的，其主要特点是直接对结构对象进行操作，不存在求导和函数连续性的区间限定，具有内在的隐并行性和更好的全局寻优能力，采用概率化的寻优方法，能自动获取和指导优化的搜索空间，自适应的调整搜索方向，不需要确定的规则，遗传算法这些性质已被">
<meta property="og:type" content="article">
<meta property="og:title" content="Genetic Algorithm">
<meta property="og:url" content="http://example.com/2021/08/24/Mathematical_modeling/11GA/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="&amp;emsp;&amp;emsp;遗传算法是借鉴生物界的进化规律(适者生存,优胜劣汰)的遗传机制，演化而来的随机全局搜索和优化算法。它是由美国教授于1975年首先提出的，其主要特点是直接对结构对象进行操作，不存在求导和函数连续性的区间限定，具有内在的隐并行性和更好的全局寻优能力，采用概率化的寻优方法，能自动获取和指导优化的搜索空间，自适应的调整搜索方向，不需要确定的规则，遗传算法这些性质已被">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/matlab/11/11-1.png">
<meta property="og:image" content="http://example.com/images/matlab/11/11-2.png">
<meta property="og:image" content="http://example.com/images/matlab/11/11-3.png">
<meta property="article:published_time" content="2021-08-24T01:04:29.000Z">
<meta property="article:modified_time" content="2021-08-26T08:40:35.955Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="遗传算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/matlab/11/11-1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Mathematical_modeling/11GA" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/24/Mathematical_modeling/11GA/" class="article-date">
  <time class="dt-published" datetime="2021-08-24T01:04:29.000Z" itemprop="datePublished">2021-08-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/">数学建模</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Genetic Algorithm
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>&amp;emsp;&amp;emsp;遗传算法是借鉴生物界的进化规律(适者生存,优胜劣汰)的遗传机制，演化而来的<strong>随机全局搜索和优化算法</strong>。它是由美国教授于1975年首先提出的，其主要特点是直接对结构对象进行操作，不存在求导和函数连续性的区间限定，具有内在的隐并行性和更好的全局寻优能力，采用概率化的寻优方法，能自动获取和指导优化的搜索空间，自适应的调整搜索方向，不需要确定的规则，遗传算法这些性质已被人们广泛的应用于组合优化机器学习信号处理，自适应控制和人工生命的领域，他是现代有关智能计算中的关键技术。</p>
<br>

<h2 id="1-遗传算法的介绍"><a href="#1-遗传算法的介绍" class="headerlink" title="1 遗传算法的介绍"></a>1 遗传算法的介绍</h2><h4 id="1-1-遗传算法的优点与不足："><a href="#1-1-遗传算法的优点与不足：" class="headerlink" title="1.1 遗传算法的优点与不足："></a>1.1 遗传算法的优点与不足：</h4><ul>
<li><p>优点</p>
<ul>
<li>不是从单个点，而是从多个点构成的，而是从多个点构成的群体开始搜索。</li>
<li>在搜索最优解过程中，只需要由目标函数转化过来的适应值信息，而不需要导数等其他值辅助信息。</li>
<li>搜索过程不宜陷入局部最优点。</li>
</ul>
</li>
<li><p>不足：  </p>
<ul>
<li>编码不规范及编码存在表示的不准确性。</li>
<li>单一的遗传算法不能全面的将优化问题得约束表示出来。考虑约束的一个方法就是对不可行解采用阈值，这样，计算的时间必然增加。</li>
<li>遗传算法的效率通常比其他传统的算法效率低。</li>
<li>遗传算法容易出现过早收敛得情况。</li>
<li>遗传算法对算法得精度、可信度、计算复杂性等方面、还没有有效的定量分析方法。</li>
</ul>
</li>
</ul>
<h4 id="1-2-遗传算法基本步骤如下："><a href="#1-2-遗传算法基本步骤如下：" class="headerlink" title="1.2 遗传算法基本步骤如下："></a>1.2 遗传算法基本步骤如下：</h4><ul>
<li>1、在一定编码条件下，随机产生初始种群。</li>
<li>2、用相应解码方法，将编码后的个体转化为问题空间的决策变量，并求得个体的适应值。</li>
<li>3、按照个体适应值大小，从种群中选出适应值较大的个体构成交配池。</li>
<li>4、用交叉和变异两个遗传算子对交配池中的个体进行操作，并形成新一代种群。</li>
<li>5、反复执行步骤2-5，直至满足收敛判据为止。</li>
</ul>
<h4 id="1-3-遗传算法的运行决定"><a href="#1-3-遗传算法的运行决定" class="headerlink" title="1.3 遗传算法的运行决定"></a>1.3 遗传算法的运行决定</h4><p>&amp;emsp;&amp;emsp;<code>编码串长度、种群大小、交叉和变异概率</code></p>
<ul>
<li><p>编码串长度：由由优化问题所求的求解精度所决定。</p>
</li>
<li><p>种群大小：种群大小表示种群所含的个体数量；</p>
<ul>
<li>种群较小时，可提高遗传算法的运行速度，但降低群体多样性，可能找不到最优解。</li>
<li>种群较大时，又会增加计算量，使遗传算法的运行效率降低。</li>
<li>一般取种群数目为<code>20-100</code>。</li>
</ul>
</li>
<li><p>交叉和变异概率：  </p>
<ul>
<li>交叉概率控制着交叉操作的频率，由于交叉操作是遗传算法中产生新个体的主要方法，所以交叉概率通常区较大值，但取值过大可能会破坏群体优良模式。一般取<code>0.4-0.99</code>.</li>
<li>变异概率也是影响新个体产生的一种因素，变异概率小，产生新个体少；变异概率大，又会使遗传算法变成随机搜索。一般变异概率取<code>0.0001-0.1</code></li>
</ul>
</li>
<li><p>遗传算法通常收敛判据；规定遗传代数，连续几次得到最优个体的适应值没有变化或变化很小。</p>
</li>
</ul>
<h4 id="1-4-遗传算法得主要应用领域"><a href="#1-4-遗传算法得主要应用领域" class="headerlink" title="1.4 遗传算法得主要应用领域"></a>1.4 遗传算法得主要应用领域</h4><center><img src="/images/matlab/11/11-1.png" width="70%" height="70%" align=center /></center>

<br>

<h2 id="2-遗传算法的基本原理"><a href="#2-遗传算法的基本原理" class="headerlink" title="2 遗传算法的基本原理"></a>2 遗传算法的基本原理</h2><p>&amp;emsp;&amp;emsp;遗传算法是一种基于自然选择和一种遗传变异等生物进化机制的全局性概率搜索算法，它在形式上也是一种迭代方法.它从选定的初始解出发，通过不断迭代，逐步改进当前解，直至最后搜索到最优解或满意解。在进化计算中，迭代计算过程采用了模拟生物体的进化机制，从一组解出发，采用类似于自然选择和有性繁殖的方式，在继承原有优良基因的基础上，生成有更好性能指标的，下一代解的群体。<br>&amp;emsp;&amp;emsp;<font face="Times New Roman ">Ga</font>有较强的全局优化能力，是一种自适应的智能的搜索技术，其主要应用领域是复杂的非线性优化问题，选择、交叉和变异是遗传算法的三个主要操作者。</p>
<h4 id="2-1-编码"><a href="#2-1-编码" class="headerlink" title="2.1 编码"></a>2.1 编码</h4><p>&amp;emsp;&amp;emsp;解空间向<font face="Times New Roman ">Ga</font>空间映射称之为编码，它是连接问题与算法的桥梁。本问题中设计变量均为连续变量，为克服二进制编码在进行连续函数离散时产生的映射误差和方便处理各约束条件，采用浮点数编码方法，染色体长度与设计变量维数相同。</p>
<p>设计变量为：<br>$$X&#x3D;[x_1,x_2,…,x_n]$$</p>
<p>染色体为：<br>$$V&#x3D;[v_{k1},v_{k2},…,v_{kn}] \quad k&#x3D;(1,2,…,m)$$</p>
<h4 id="2-2-适应度评价函数"><a href="#2-2-适应度评价函数" class="headerlink" title="2.2 适应度评价函数"></a>2.2 适应度评价函数</h4><p>&amp;emsp;&amp;emsp;度量个体适应度的函数称之为适应度函数。实际工程3优化问题一般都有一定的约束条件，惩罚技术时求解约束优化问题。在遗传算法中，惩罚技术用来在每代的种群中保持部分不可行解，使用遗传算法搜索可以从可行域和不可行域两边来达到最优解。</p>
<p>对于非线性数学规划问题：<br>$$<br>min \quad f(x)\<br>s.t.\quad g_i(X)\ge0 \quad (i&#x3D;1,2,…,m)<br>$$</p>
<p>本题中按照外点发构造惩罚函数：<br>$$<br>\phi(X,r^{k})&#x3D;f(x)+r^{k}{\sum_{\mu&#x3D;1}^m min[g_\mu (X),0]^2}<br>$$</p>
<p>式子中。$r^k$为<code>惩罚因子</code>，是一个单调递增正值序列，$r^{k+1}&#x3D;er^k$，许多计算经验表明，若区$r^0&#x3D;1$，和$e&#x3D;5\sim 10$，可以取到满意的结果。</p>
<h4 id="2-3-选择算子"><a href="#2-3-选择算子" class="headerlink" title="2.3 选择算子"></a>2.3 选择算子</h4><p>&amp;emsp;&amp;emsp;选择操作建立对个体的适应度进行评价的基础上，选择操作的目的是把优化的个体直接遗传到下一代，或通过配对交叉产生新的个体再遗传到下一代。比例选择是最常用的选择算子，它是一种回放式随机采样方式。设群体规模为$m$，个体$i$，的适应度为$F$，则个体$i$，被选中的概率$p_i$为：<br>$$P_{is}&#x3D;F_i&#x2F;\sum_{i&#x3D;1}^m F_i$$</p>
<p>适应度函数数值越高的染色体被选中的概率越大。</p>
<h4 id="2-4-交叉算子"><a href="#2-4-交叉算子" class="headerlink" title="2.4 交叉算子"></a>2.4 交叉算子</h4><p>&amp;emsp;&amp;emsp;首先定义交叉操作的概率 $P_c$ ，一般建议取值范围为<code>0.4-0.99</code>。然后按照概率 $P_c$ ，把两个父代个体的部分结构加以交换重组而生成新的个体。浮点数编码方法表达的个体在进行交叉时一般是进行算数交叉。假设在两个个体 $X_A^t$，$X_B^t$，之间进行算数交叉，则交叉运算后所产生的两个新个体是：<br>$$<br>\begin{cases}<br>X_A^{t+1}&#x3D;aX_B^t+(1-a)X_A^t  \<br>X_B^{t+1}&#x3D;aX_A^t+(1-a)X_B^t<br>\end{cases}<br>$$</p>
<p>式子中，$a$为交叉参数，$a\in(0,1)$ 。它可以是一个常数，此时称之为均匀算数交叉；也可以是一个由此进化代数所决定的变量，此时称非均匀算数交叉。</p>
<h4 id="2-5-变异算子"><a href="#2-5-变异算子" class="headerlink" title="2.5 变异算子"></a>2.5 变异算子</h4><p>&amp;emsp;&amp;emsp;变异算子是实数编码编遗传算法中起到重大作用。在实数编码时，变异算子不在像二进制编码时仅仅是简单的恢复群体中多样性的损失，它她已经成为一个主要的搜索算子。定义参数 $P_m$ ，作为变异操作的概率，建议取值范围为<code>0.01-0.1</code>。采用非均匀变异：设个体 $X&#x3D;x_1x_2···x_k···x_l$，其中变异点的新基因为：<br>$$<br>X^{‘}<em>k&#x3D;<br>\begin{cases}<br>x_k+(U^k</em>{max}-x_k)(1-r^{b(1-G&#x2F;T)}) \quad Random(0,1)&#x3D;1 \<br>x_k-(x_k-U^k_{min})(1-r^{b(1-G&#x2F;T)}) \quad Random(0,1)&#x3D;0<br>\end{cases}<br>$$<br>式中，$Random(0,1)$ 表示以均等的概率从 $0,1$ 中任取其一；$r$为$[0,1]$范围内符合均匀分布的一个随机数；$G$ 为当前代数；$T$为终止代数；$b$为调整变异步长的参数，随进化代数 $G$ 而动态变化。</p>
<h4 id="2-6-终止代数"><a href="#2-6-终止代数" class="headerlink" title="2.6 终止代数"></a>2.6 终止代数</h4><p>&amp;emsp;&amp;emsp;经过选择、交叉和变异操作就能得到一个新的种群，上述步骤经过给定的循环次数后，遗传算法终止，并将当前种群中最佳的个体作为所求问题的最优解输出。对于终止代数，建议取值范围为<code>100-500</code>。</p>
<br>

<h2 id="遗传算法工具箱"><a href="#遗传算法工具箱" class="headerlink" title="遗传算法工具箱"></a>遗传算法工具箱</h2><h4 id="3-1-ga-m函数"><a href="#3-1-ga-m函数" class="headerlink" title="3.1 ga.m函数"></a>3.1 <font face="Times New Roman " ><strong>ga.m</strong></font>函数</h4><p>&amp;emsp;&amp;emsp;<font face="Times New Roman " ><strong>ga.m</strong></font>函数是Matlab遗传算法工具箱和外部接口，在实际优化过程中，编写好目标函数，设定参数，调用<font face="Times New Roman " ><strong>ga.m</strong></font>便可实现优化。</p>
<h4 id="3-2-算子函数"><a href="#3-2-算子函数" class="headerlink" title="3.2 算子函数"></a>3.2 算子函数</h4><p>&amp;emsp;&amp;emsp;算子函数包含<code>交叉算子</code>和<code>变异算子</code>，算子函数提供了遗传算法搜索机制，通过算子函数，在原来基础上产生新的种群。</p>
<ul>
<li>交叉算子：<font face="Times New Roman " ><strong>function</strong>[child1,child2]&#x3D;<strong>crossover</strong>(parent1,parent2,bounds,params)</font>.</li>
<li>变异算子：<font face="Times New Roman " ><strong>function</strong>[child]&#x3D;<strong>mutation</strong>(parent,bounds,params)</font>。</li>
</ul>
<p>二者不同的是，交叉算子由两个父代产生两个新的子代，而变异算子则是由一个父代产生一个新的子代。</p>
<h4 id="3-3-选择函数"><a href="#3-3-选择函数" class="headerlink" title="3.3 选择函数"></a>3.3 选择函数</h4><p>选择函数：<font face="Times New Roman " ><strong>function</strong>[newPop]&#x3D;<strong>slectFuntion</strong>(oldPop,options)</font>,决定哪些个体进入下一代。 </p>
<ul>
<li><font face="Times New Roman " >newPop</font>是被选中的新种群；</li>
<li><font face="Times New Roman " >oldPop</font>是当前种群；</li>
<li><font face="Times New Roman " >options</font>是其他可选参数向量；<ul>
<li><font face="Times New Roman " >roulette.m</font>  </li>
<li><font face="Times New Roman " >normGeomSelsct.m</font> </li>
<li><font face="Times New Roman " >tourn.m</font></li>
</ul>
</li>
</ul>
<h4 id="3-4-初始化函数和终止函数"><a href="#3-4-初始化函数和终止函数" class="headerlink" title="3.4 初始化函数和终止函数"></a>3.4 初始化函数和终止函数</h4><p>&amp;emsp;&amp;emsp;遗传算法工具箱给出了 <font face="Times New Roman " >innitializega.m</font> 和 <font face="Times New Roman " >initializeoga.m</font> 两个种群初始优化函数和<font face="Times New Roman " > maxGenTerm.m </font>、<font face="Times New Roman " >optMaxGenTerm.m </font>两个终止函数。</p>
<p>&amp;emsp;&amp;emsp;遗传算法工具箱已经在多维变量优化、非线性规划、参数优化和动态系统最优控等一系列领域有了很好的应用。</p>
<br>

<h2 id="4-遗传算法在Matlab中实现"><a href="#4-遗传算法在Matlab中实现" class="headerlink" title="4 遗传算法在Matlab中实现"></a>4 遗传算法在Matlab中实现</h2><h4 id="4-1-编码"><a href="#4-1-编码" class="headerlink" title="4.1 编码"></a>4.1 编码</h4><p>遗传算法不对优化问题的实际决策变量进行操作，所以应用遗传算法首要问题是通过编码来将决策变量表示成串结构数据。采用最常用的二进制编码方案，即通过二进制数构成的符号串来表示一个个体，用下面的<font face="Times New Roman " > <strong>encoding</strong> </font>函数来实现编码并产生初始种群： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function[bin_gen,bits]=encoding(min_var,max_var,scale_var,popsize)</span><br><span class="line">  bits=ceil(log2((max_var-min_var)./scale_var));</span><br><span class="line">  bin_gen=randint(popsize,sum(bits));</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>&amp;emsp;&amp;emsp;在上面代码中，首先根据决策变量的下界<font face="Times New Roman">(min_var)</font>、上界<font face="Times New Roman">(max_var)</font>及其搜索精度<font face="Times New Roman">(scale_var)</font>来确定表示各决策变量的二进制串的长度<font face="Times New Roman">bits</font>，然后随机产生一个种群大小为 <font face="Times New Roman"> popsize </font>的初始种群<font face="Times New Roman"> bin_gen </font>。编码后的实际搜索精度为<font face="Times New Roman"> scale_dec (max_var-min_var)&#x2F;(2^bits-1) </font>，该精度会在解码时用到。</p>
<h4 id="4-2-解码"><a href="#4-2-解码" class="headerlink" title="4.2 解码"></a>4.2 解码</h4><p>&amp;emsp;&amp;emsp;编码后的个体构成的种群<font face="Times New Roman"> bin_gen </font>必须经过解码以转换成原问题空间的决策变量构成的种群<font face="Times New Roman"> var_gen </font>，才能计算相应的适应值。用下面代码实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function[var_gen,fitness] = decoding (funname,bin_gen,bits,min_var,max_var)</span><br><span class="line">    num_var=lenth(bits);</span><br><span class="line">    popsize=size(bin_gen,1);</span><br><span class="line">    scale_dec=(max_var-min_var)./(2.^bits-1);</span><br><span class="line">    bits=[o bits];</span><br><span class="line">    for i=1:num_var</span><br><span class="line">      bin_var(i)=bin-gen(:,bits(i):bits(i+1));</span><br><span class="line">      var(i)=sum(ones(popsize,1)*2.^(size(bin_var(i),2)-1:-1:0).*bin_var(i),2).*scale_dec(i)+min_var(i)</span><br><span class="line">    end</span><br><span class="line">    var_gen=[var(1,:)];</span><br><span class="line">    for i=1:popsize</span><br><span class="line">      fitness(i)=eval(funname,&#x27;(var_gen(I,:))&#x27;);</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<p>&amp;emsp;&amp;emsp;解码函数的关键在于先由二进制数求得对应的十进制数 $D$ ，并根据下式得出实际决策变量值 $X$ ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=D*scale_dec+min_var</span><br></pre></td></tr></table></figure>

<h4 id="4-3-选择"><a href="#4-3-选择" class="headerlink" title="4.3 选择"></a>4.3 选择</h4><p>&amp;emsp;&amp;emsp;选择过程是利用解码后求得的各个适应值的大小，淘汰一些较差的个体而选出一些比较优良的个体，以进行下一步交叉变异操作。选择算子的程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">funcion[evo_gen,best_indiv,max_fitness] = selection(old_gen,fitness)</span><br><span class="line">popsize = length(fitness);</span><br><span class="line">[max_fitness,index1] = max(fitness);</span><br><span class="line">[min_fitness,index2] = min(fitness);</span><br><span class="line">best_indiv = old_gen(index1,:);</span><br><span class="line">index = [1;popsize];</span><br><span class="line">index(index1)= 0 ;</span><br><span class="line">index(index2)= 0 ;</span><br><span class="line">index=nonzeros(index);</span><br><span class="line">evo.gen = old-gen(index,:);</span><br><span class="line">evo_fitness = fitness(index,:);</span><br><span class="line">evo_popsize = popsize - 2;</span><br><span class="line">ps=evo_fitness/sum(evo_fitness);</span><br><span class="line">pscum = cumsum(ps);</span><br><span class="line">r = rand(1,evo_popsize);</span><br><span class="line">selscted = sum(pscum*ones(1,evo_popsize)&lt;ones(evo_popsize,1)*r)+1;</span><br><span class="line">evo_gen = evo_gen(selscted,:);</span><br></pre></td></tr></table></figure>

<p>&amp;emsp;&amp;emsp;在该算子中，采用最优保存策略和比例保存法相结合的思路，即首先找出当前群体中适应值最高和最低的个体，将最佳个体<font face="Times New Roman"> best_indiv </font> 保留并用其替换最差个体，为保证当前最佳个体不被交叉、变异操作所破坏，允许其不参与交叉和变异直接进入下一代，然后将剩下的个体<font face="Times New Roman"> evo_gen </font > 按照比例法进行操作。所谓比例选择法，也叫轮盘赌算法，是指个体被选中的概率和该个体的适应值大小成正比。将两种方法结合的目的是：在遗传操作中，不仅能不断提高群体的平均适应值，而且能保证最佳适应值不减小。</p>
<h4 id="4-4-交叉"><a href="#4-4-交叉" class="headerlink" title="4.4 交叉"></a>4.4 交叉</h4><p>&amp;emsp;&amp;emsp;下面采用单点交叉的方法来实现交叉算子，即按选择概率<font face ="Times New Roman"> pc </font>在两两配对的个体编码串 <font face ="Times New Roman"> cpairs </font>中随机设置一个交叉点<font face ="Times New Roman"> cpoints </font>，然后在该点互相交换两个配对个体的部分基因，从而形成两个新的个体，交叉算子程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function new_gen = crossover (old_gen,pc)</span><br><span class="line">  [nouse,mating] = sort(rand(size(old_gen,1),1));</span><br><span class="line">  mat_gen = old_gen(mating,:);</span><br><span class="line">  pairs = size(mat_gen,1)/2;</span><br><span class="line">  bits = size(mat_gen,2);</span><br><span class="line">  cpairs = rand(pairs,1)&lt;pc;</span><br><span class="line">  cpoints = randint(pairs,1,[1,bits]);</span><br><span class="line">  cpoints = cpairs.*cpoints;</span><br><span class="line">  for i=1:pairs</span><br><span class="line">    new_gen([2*i-1 2*i],:) = [mat_gen([2*i-1 2*i],1:cpoints(i))mat_gen([2*i 2*i-1],cpoints(i)+1:bits)];</span><br><span class="line">  end</span><br></pre></td></tr></table></figure>

<h4 id="4-5-变异"><a href="#4-5-变异" class="headerlink" title="4.5 变异"></a>4.5 变异</h4><p>&amp;emsp;&amp;emsp;对于二进制的基因串而言，变异操作就是按照变异的概率<font face ="Times New Roman"> pm </font>随机选择变异点<font face ="Times New Roman"> mpoints </font>，在变异点将其取反即可。变异算子的实现过程如下；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">funtion new_gen = mutation(old_gen,pm)</span><br><span class="line">  mpoints = find(rand(size(old_gen))&lt;pm);</span><br><span class="line">  new_gen = old_gen;</span><br><span class="line">  new_gen(mpoints) = 1-old_gen*(mppints);</span><br></pre></td></tr></table></figure>

<h2 id="5-简单一元函数优化实例"><a href="#5-简单一元函数优化实例" class="headerlink" title="5 简单一元函数优化实例"></a>5 简单一元函数优化实例</h2><p>用遗传算法计算下面函数的最大值：<br>$$f(x)&#x3D;x sin(10\pi x)+2.0 \qquad x\in [-1,2]$$  </p>
<p>&amp;emsp;&amp;emsp;选择二进制编码，种群个体数量为 $40$ ，每个种群长度为 $20$ ，使用代沟为 $0.9$ ，最大遗传代数为 $25$ 。</p>
<ul>
<li>代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line">figure(1)</span><br><span class="line">fplot(&#x27;variable.*sin(10*pi*variable)+2.0&#x27;,[-1,2])</span><br><span class="line">nind=40;</span><br><span class="line">maxgen=25;</span><br><span class="line">preci=20;</span><br><span class="line">GGAP=0.9;</span><br><span class="line">trace=zeros(2,maxgen);</span><br><span class="line">fieldD=[20;-1;2;1;0;1;1];</span><br><span class="line">chrom=crtbp(nind,preci);</span><br><span class="line">gen=0;</span><br><span class="line">variable=bs2rv(chrom,fieldD);</span><br><span class="line">objv=variable.*sin(10*pi*variable)+2.0;</span><br><span class="line">while gen&lt;maxgen</span><br><span class="line">    FitnV=ranking(-objv);</span><br><span class="line">    selch=select(&#x27;sus&#x27;,chrom,FitnV,GGAP);</span><br><span class="line">    selch=recombin(&#x27;xovsp&#x27;,selch,0.7);</span><br><span class="line">    selch=mut(selch);7</span><br><span class="line">    variable=bs2rv(selch,fieldD);</span><br><span class="line">    objvsel=variable.*sin(10*pi*variable)+2.0;</span><br><span class="line">    [chrom,objv]=reins(chrom,selch,1,1,objv,objvsel);</span><br><span class="line">    gen=gen+1;</span><br><span class="line">    [Y,I]=max(objv),hold on;</span><br><span class="line">    plot(variable(I),Y,&#x27;bo&#x27;);</span><br><span class="line">    trace(1,gen)=max(objv);</span><br><span class="line">    trace(2,gen)=sum(objv)/length(objv);</span><br><span class="line">end</span><br><span class="line">variable=bs2rv(chrom,fieldD);</span><br><span class="line">hold on;grid;</span><br><span class="line">plot(variable&#x27;,objv&#x27;,&#x27;b*&#x27;);</span><br><span class="line">figure(2)</span><br><span class="line">plot(trace(1,:)&#x27;);</span><br><span class="line">hold on;</span><br><span class="line">plot(trace(2,:)&#x27;,&#x27;-&#x27;);grid;</span><br><span class="line">legend(&#x27;解的变化&#x27;,&#x27;种群均值变化&#x27;)</span><br><span class="line">disp([&#x27;输出最大值为&#x27;,num2str(Y)])</span><br></pre></td></tr></table></figure></li>
</ul>
<p>下图展示的是经过多次遗传，得出的最优良子代汇聚结果：</p>
<center><img src="/images/matlab/11/11-2.png" width="70%" height="70%" align=center /></center>

<br>

<p>下图是每代得到的结果：</p>
<center><img src="/images/matlab/11/11-3.png" width="70%" height="70%" align=center /></center>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/24/Mathematical_modeling/11GA/" data-id="cl3qp641v000ez4qfd4tl9s2s" data-title="Genetic Algorithm" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/" rel="tag">遗传算法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/29/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
    <a href="/2021/08/15/Mathematical_modeling/10matlab/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Matlab微分方程</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/">数学建模</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Arduino/" rel="tag">Arduino</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lingo%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/" rel="tag">Lingo案例分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/" rel="tag">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matlab%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">Matlab基础知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/matlab%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">matlab基础知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/matlab%E5%BA%94%E7%94%A8/" rel="tag">matlab应用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/matlab%E7%A8%8B%E5%BA%8F/" rel="tag">matlab程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/matlab%E7%BB%98%E5%9B%BE/" rel="tag">matlab绘图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/" rel="tag">微分方程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E6%A2%B0%E5%8E%9F%E7%90%86/" rel="tag">机械原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E6%A2%B0%E8%AE%BE%E8%AE%A1/" rel="tag">机械设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%A9%E6%9C%BA/" rel="tag">玩机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E6%8E%92%E7%89%88/" rel="tag">论文排版</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/" rel="tag">遗传算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Arduino/" style="font-size: 12.5px;">Arduino</a> <a href="/tags/Git/" style="font-size: 12.5px;">Git</a> <a href="/tags/Github/" style="font-size: 20px;">Github</a> <a href="/tags/Hexo/" style="font-size: 20px;">Hexo</a> <a href="/tags/Lingo%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/" style="font-size: 12.5px;">Lingo案例分析</a> <a href="/tags/Math/" style="font-size: 12.5px;">Math</a> <a href="/tags/Matlab%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 12.5px;">Matlab基础知识</a> <a href="/tags/Python/" style="font-size: 12.5px;">Python</a> <a href="/tags/markdown/" style="font-size: 12.5px;">markdown</a> <a href="/tags/matlab%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 12.5px;">matlab基础知识</a> <a href="/tags/matlab%E5%BA%94%E7%94%A8/" style="font-size: 17.5px;">matlab应用</a> <a href="/tags/matlab%E7%A8%8B%E5%BA%8F/" style="font-size: 12.5px;">matlab程序</a> <a href="/tags/matlab%E7%BB%98%E5%9B%BE/" style="font-size: 12.5px;">matlab绘图</a> <a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 12.5px;">单片机</a> <a href="/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/" style="font-size: 12.5px;">微分方程</a> <a href="/tags/%E6%9C%BA%E6%A2%B0%E5%8E%9F%E7%90%86/" style="font-size: 20px;">机械原理</a> <a href="/tags/%E6%9C%BA%E6%A2%B0%E8%AE%BE%E8%AE%A1/" style="font-size: 12.5px;">机械设计</a> <a href="/tags/%E7%8E%A9%E6%9C%BA/" style="font-size: 12.5px;">玩机</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E8%AE%BA%E6%96%87%E6%8E%92%E7%89%88/" style="font-size: 12.5px;">论文排版</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 12.5px;">语法</a> <a href="/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/" style="font-size: 10px;">遗传算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/29/Learn/math/">Mathjax渲染公式</a>
          </li>
        
          <li>
            <a href="/2022/05/29/%E5%AD%A6%E4%B9%A0/math/">Mathjax渲染公式</a>
          </li>
        
          <li>
            <a href="/2022/05/29/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/08/24/Mathematical_modeling/11GA/">Genetic Algorithm</a>
          </li>
        
          <li>
            <a href="/2021/08/15/Mathematical_modeling/10matlab/">Matlab微分方程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>